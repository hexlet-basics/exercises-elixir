---

name: Атомы и кортежи
theory: |

  *Атомы* типичны для функциональных языков, но редко встречаются в языках императивных. Это некие константные значения, которые можно сравнивать друг с другом. Собственно, сравнивать — это единственное, что с ними можно делать. Сами по себе они не очень полезны, но становятся полезны в комплекте с кортежами и сопоставлением с образцом (pattern matching).

  ```elixir
  :user
  :point
  :ip_address
  ```

  *Кортеж (tuple)* — это структура данных, объединяющая несколько разных значений. Кортеж похож на список, но в отличие от списка имеет фиксированную длину.

  ```elixir
  {"Bob", :male, 23}
  {1, 2}
  {127, 0, 0, 1}
  ```

  В кортежах на первой позиции часто ставят атом, чтобы обозначить, что за данные собраны в кортеже. Таким образом кортеж помечается тэгом (tagged tuple).

  ```elixir
  {:user, "Bob", :male, 23}
  {:point, 1, 2}
  {:ip_address, 127, 0, 0, 1}
  ```

  Кортежи могут быть вложенными:

  ```elixir
  {:rectangle, {:point, 0, 0}, {:point, 10, 10}}
  {:ip4, {127, 0, 0, 1}}
  ```

  Небольшие объекты, состоящие из 2-4 полей, удобно представлять в виде кортежей, если роль полей понятна из контекста. В ином случае нужно использовать *словарь (map)* или *структуру (struct)*.

  Атомы и кортежи — это легковесные объекты, они используют меньше памяти, чем словари и структуры, и операции над ними выполняются быстрее.

  Сопоставление с образцом мы будем изучать подробно. Сейчас важно знать, что это способ извлечь отдельные значения из кортежа:

  ```elixir
  my_point = {:point, 5, 10}
  {:point, x, y} = my_point
  IO.puts(x) # => 5
  IO.puts(y) # => 10
  ```

  Рассмотрим реализацию функции distance, которая вычисляет расстояние между двумя точками:

  ```elixir
  def distance(point1, point2) do
    {:point, x1, y1} = point1
    {:point, x2, y2} = point2
    x_dist = abs(x1 - x2)
    y_dist = abs(y1 - y2)
    :math.sqrt(:math.pow(x_dist, 2) + :math.pow(y_dist, 2))
  end
  ```

  Функция принимает в аргументах две точки, извлекает их координаты с помощью сопоставления с образцом, и по теореме Пифагора вычисляет расстояние между точками.

  Для этого применяется модуль *:math* из языка Эрланг, потому что у Эликсир нет своего такого модуля в стандартной библиотеке (есть в сторонних библиотеках). Если бы такой модуль был, то код выглядел бы так:

  ```elixir
  Math.sqrt(Math.pow(x_dist, 2) + Math.pow(y_dist, 2))
  ```

  Обычно извлечение значений из кортежа с помощью сопоставления с образцом делают прямо в аргументах функции:

  ```elixir
  def distance({:point, x1, y1}, {:point, x2, y2}) do
    x_dist = abs(x1 - x2)
    y_dist = abs(y1 - y2)
    :math.sqrt(:math.pow(x_dist, 2) + :math.pow(y_dist, 2))
  end
  ```

  Результат работы функции:

  ```elixir
  distance({:point, 0, 0}, {:point, 0, 5})  # 5.0
  distance({:point, 2, 2}, {:point, 10, 12})  # 12.806248474865697
  distance({:point, -5, -5}, {:point, 10, 10})  # 21.213203435596427
  ```

  При объявлении, атом сохраняется внутри памяти программы в виде числа, из-за чего сравнения атомов происходят быстрее, чем строк. Однако, если бесконтрольно объявлять атомы, например, из пользовательского ввода, то память приложения может переполнится, так как атомы не вычищаются сборщиком мусора BEAM. Хоть и максимальное число атомов, которые можно создать - 1,048,576, всё равно не стоит заводить атомы на каждый чих. 
  
instructions: |

  Реализовать функцию `is_point_inside_circle(point, circle)`, которая принимает точку и окружность, и возвращает `true`, если точка находится внутри окружности, или `false`, если точка находится снаружи.
  
  Реализовать функцию `is_point_inside_rect(point, rect)`, которая принимает точку и прямоугольник, и возвращает `true`, если точка находится внутри прямоугольника, или `false`, если точка находится снаружи.

  Точка представлена кортежем `{:point, x, y}`.

  Окружность представлена кортежем `{:circle, center, radius}`, где center — это кортеж `:point`.

  Прямоугольник представлен кортежем `{:rect, left_top, right_bottom}`, где `left_top` и `right_bottom` — это кортежи `:point`.

  Уже реализованная функция distance может вам пригодиться:

  ```elixir
  defmodule Solution do

    def distance({:point, x1, y1}, {:point, x2, y2}) do
      # ...
    end

    def is_point_inside_circle(point, circle) do
      # TODO реализация
    end

    def is_point_inside_rect(point, rect) do
      # TODO реализация
    end

  end
  ```

tips:
  - |
    [Официальная документация](https://hexdocs.pm/elixir/Atom.html)
  - |
    [Почему максимальное число атомов 1,048,576](https://www.erlang.org/doc/man/erl.html#+t)
