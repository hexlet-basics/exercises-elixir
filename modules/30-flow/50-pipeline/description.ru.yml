---

name: Оператор pipe
theory: |

  Одна из фишек Эликсир -- оператор *pipe*. Это удобный способ написания цепочек вызовов функций, где результат одной функции является аргументом для другой.

  В большинстве языков в такой ситуации используют либо временные переменные:

  ```elixir
  a = func1()
  b = func2(a)
  c = func3(b)
  ```

  либо вложенные вызовы:

  ```elixir
  func3(func2(func1())
  ```

  Но pipe позволяет написать код короче и с естественным порядком функций в цепочке:

  ```elixir
  func1() |> func2() |> func3()
  ```

  Оператор принимает значение из одной функции, и передаёт его первым аргументом во вторую функцию. Если у функции больше одного аргумента, то их нужно указать явно:

  ```elixir
  Map.put(%{}, :a, 1) |> Map.put(:b, 2) |> Map.put(:c, 3) #  %{a: 1, b: 2, c: 3}
  ```

  pipe настолько важен, что все функции системных библиотек рассчитаны на его использование. Например, большинство функций в модуле *Map* первым аргументом принимают Map, поэтому их легко собирать в цепочку.

  ```elixir
  Map.new() |> Map.put_new(:a, 1) |> Map.to_list() # [a: 1]
  ```

  Рекомендуется придерживаться такого же подхода в своих собственных функциях.


instructions: |

  Посмотрите документацию для модуля *String*. Найдите функции для удаления пробельных символов в начале и конце строки, для приведения строки к нижнему регистру, и для дублирования строки несколько раз.

  Нужно собрать эти три функции в цепочку, таким образом, чтобы строка на входе была очищена от лишних пробелов, приведена в нижний регистр и продублирована указанное количество раз:

  ```elixir
  Solution.process(" My Cool String  ", 2) # "my cool stringmy cool string"
  ```

tips:
  - |
    [String](https://hexdocs.pm/elixir/String.html)
