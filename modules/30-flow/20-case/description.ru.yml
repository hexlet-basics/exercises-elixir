---

name: Конструкция case
theory: |

  Условные переходы в функциональных языках отличаются от императивных, потому что основаны на сопоставлении с образцом. Основная идея в том, что некое значение по-очереди сравнивается с несколькими шаблонами, и в зависимости от того, с каким шаблоном оно совпадет, выполняется та или иная ветка кода.

  Есть несколько вариантов условных переходов:
  - конструкция case;
  - конструкция cond;
  - тело функции (function clause);
  - обработка исключений (resque, catch);
  - чтение сообщений из mailbox (receive). 

  Все они, кроме *cond*, реализуют эту идею. 

  ## Рассмотрим конструкцию case.

  Для примера рассмотрим вычисление наибольшего общего делителя:
    
  ```elixir
  def gcd(a, b) do
    case rem(a, b) do
      0 -> b
      c -> gcd(b, c)
    end
  end
  ```
  
  Здесь вычисляется значение `rem(a, b)` и сравнивается с двумя шаблонами. Первый шаблон -- литерал `0`. Если значение совпадает с ним, то выполняется код, завершающий рекурсию и возвращающий `b`. Второй шаблон -- переменная `c`. С этим шаблоном совпадут любые значения, и тогда выполняется вызов `gcd(b, c)`.

  Второй пример:
    
  ```elixir
  case Map.fetch(acc, word) do
    {:ok, count} -> Map.put(acc, word, count + 1)
    :error -> Map.put(acc, word, 1)
  end
  ```
  
  Здесь выполняется вызов функции `Map.fetch(acc, word)`. Получившееся значение сравнивается с двумя шаблонами и выполняется соответствующий код.

  Шаблонов может быть несколько. И важен их порядок, потому что первый совпавший шаблон останавливает перебор оставшихся шаблонов. Если не совпал ни один из шаблонов, то генерируется исключение.

  В общем виде конструкция *case* выглядит так:
    
  ```elixir
  case Expr do
      Pattern1 [when GuardSequence1] ->
          Body1
      ...
      PatternN [when GuardSequenceN] ->
          BodyN
  end
  ```
  
  Что такое GuardSequence -- цепочка охранных выражений, мы рассмотрим позже.

  case могут быть вложенными друг в друга:
    
  ```elixir
  def handle(animal, action) do
    case animal do
      {:dog, name} ->
        case action do
          :add -> IO.puts("add dog #{name}")
          :remove -> IO.puts("remove dog #{name}")
        end
      {:cat, name} ->
        case action do
          :add -> IO.puts("add cat #{name}")
          :remove -> IO.puts("remove cat #{name}")
        end
    end
  end
  ```

  Вложенный даже на два уровня код плохо читается. Обычно этого можно избежать. Данный пример можно реализовать без вложенного case таким образом:
    
  ```elixir
  def handle2(animal, action) do
    case {animal, action} do
      {{:dog, name}, :add} -> IO.puts("add dog #{name}")
      {{:dog, name}, :remove} -> IO.puts("remove dog #{name}")
      {{:cat, name}, :add} -> IO.puts("add cat #{name}")
      {{:cat, name}, :remove} -> IO.puts("remove cat #{name}")
    end
  end
  ```

  ## Охранные выражения (Guards)

  Теперь вернемся к упомянутым выше охранным выражениям. 

  Не всегда достаточно шаблона, чтобы проверить все условия для ветвления в коде. Например, шаблоном нельзя проверить попадание числа в определенный диапазон.

  ```elixir
  def handle4(animal) do
    case animal do
      {:dog, name, age} when age > 10 -> IO.puts("#{name} is a dog older than 10")
      {:dog, name, _} -> IO.puts("#{name} is a 10 years old or younger dog")
      {:cat, name, age} when age > 10 -> IO.puts("#{name} is a cat older than 10")
      {:cat, name, _} -> IO.puts("#{name} is a 10 years old or younger cat")
    end
  end
  ```

  Охранное выражение представляет собой предикат или цепочку предикатов:

  ```elixir
  when predicat1 and predicat2 or ... predicatN ->
  ```

  В предикатах можно использовать ограниченный набор функций, описанный в [документации](https://hexdocs.pm/elixir/patterns-and-guards.html#list-of-allowed-functions-and-operators). Некоторые функциональные языки разрешают вызывать любые функции в охранных выражениях. Но Эликсир не относится к таким языкам.

  Если при вычислении охранного выражения возникает исключение, то оно не приводит к остановке процесса, а приводит к тому, что все выражение вычисляется в false. Это позволяет писать выражения проще. Вместо:

  ```elixir
  when is_map(a) and map_size(a) > 10 ->
  ```
  
  можно сразу писать:
    
  ```elixir
  when map_size(a) > 10 ->
  ```

instructions: |

  В разработке

tips: []
