---

name: Свертка
theory: |

  Функции `map` и `filter` обрабатывают списки, сохраняя саму структуру. Иногда нужно избавиться от этой структуры, вычислив какое-то итоговое значение. Простейший пример — сумма всех чисел в списке, либо текст, собранный из списка строк.

  В процедурных языках для получения итоговых значений по списку проходят с использованием цикла и промежуточный результат хранят в отдельной переменной — *аккумуляторе*.

  Декларативным же аналогом такого цикла будет операция *сворачивания* (*folding*) или, как ещё говорят, получение *свёртки* (*fold*). Суть сворачивания списка заключается в последовательном применении некоторой *операции* к очередному элементу списка и текущему значению аккумулятора `acc` с целью получить новое значение аккумулятора. Рассмотрим процесс сворачивания списка `[1, 2, 3, 4]` в сумму чисел. Начальным значением аккумулятора будет `0`, а операцией — `+`. Сложить числа можно как минимум двумя способами:

  1. двигаясь от первого элемента к последнему, слева-направо:
    ```
    (((0 + 1) + 2) + 3) + 4
    ```
  2. двигаясь от последнего элемента к первому, справа-налево:
    ```
    1 + (2 + (3 + (4 + 0)))
    ```

  Для операции сложения не имеет значения то, какой из вариантов мы выберем. Потому что операция сложения [ассоциативна](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F). Но далеко не все операции таковы: например, при конкатенации строк важно, последнюю мы будем с первой складывать или наоборот.

  ```elixir
  Enum.reduce([1, 2, 3], 0, &(&1 + &2)) # => 6
  Enum.reduce([1, 2, 3], 0, fn x, acc -> acc - x end) # => -6

  Enum.reduce(["a", "b", "c"], "", fn x, acc -> "#{acc}#{x}" end) # => "abc"
  Enum.reverse(["a", "b", "c"]) |> Enum.reduce("", fn x, acc -> "#{acc}#{x}" end) # => "cba"
  ```

  Часто используют левую свёртку `reduce` из модуля `Enum` потому, что она более интуитивна — двигается от первого элемента к последнему. Однако, иногда полезна правая.

  Если появилась необходимость использовать правую свертку, то можно обратиться к модулю `List` и функции `foldr`, однако стоит понимать, что в общем случае лучше использовать `Enum`, так как модуль работает со всеми структурами, имплементирующими протокол `Enumerable`, в то время как `List` работает только со списками. Про протоколы будет рассказано чуть позже.

  ```elixir
  List.foldr([1, 2, 3], 0, &(&1 + &2)) # => 6
  List.foldr([1, 2, 3], 0, fn x, acc -> acc - x end) # => -6

  List.foldl(["a", "b", "c"], "", fn x, acc -> "#{acc}#{x}" end) # => "abc"
  List.foldr(["a", "b", "c"], "", fn x, acc -> "#{acc}#{x}" end) # => "cba"
  ```

instructions: |

  Реализуйте функцию `max_delta`, которая должна принимать два списка чисел и вычислять максимальную разницу (абсолютное значение разницы) между соответствующими парами элементов. Примеры:

  ```elixir
  Solution.max_delta([], [])
  # => 0
  Solution.max_delta([10, -15, 35], [2, -12, 42])
  # => 8
  Solution.max_delta([-5], [-15])
  # => 10
  ```

  Вам пригодятся функции `abs` и `max`:

  ```elixir
  abs(42)    # => 42
  abs(-13)   # => 13
  max(1, 5)  # => 5
  ```

tips:
  - |
    [Про map, filter, reduce](https://ru.hexlet.io/blog/posts/js-prosto-o-slozhnom-filter-map-reduce)
